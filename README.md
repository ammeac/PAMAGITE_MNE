# HTML - Язык разметки текста

## Что такое HTML?

*   **HTML (HyperText Markup Language)** - язык гипертекстовой разметки.
*   Язык разметки электронных документов.
*   Указывает браузерам, как представлять информацию.

## Создание HTML документа

1.  Создать текстовый файл с расширением `.txt`.
2.  Изменить расширение на `.html`.
3.  Открыть файл в текстовом редакторе (например, Блокнот).
4.  Написать HTML-код.

## Структура HTML-документа

HTML состоит из набора специальных правил (тегов).
Теги заключаются в угловые скобки (`<` и `>`).
Теги бывают парные (контейнеры) и одинарные.

Пример парного тега: `<B>Жирный текст</B>`.
Пример одинарного тега: `<p>Новый абзац`.

Основные разделы HTML-документа:

HTML`: Определяет, что это HTML-документ.
HEAD`: Содержит заголовки и метаданные документа.
BODY`: Содержит основное содержимое документа, отображаемое в браузере.

*   Пример структуры:
*   html
    <HTML>
    <HEAD>
    содержимое раздела HEAD
    </HEAD>
    <BODY>
    содержимое раздела BODY
    </BODY>
    </HTML>

    
## Содержимое раздела HEAD

TITLE: Название документа (отображается в заголовке окна браузера).
 LINK: Связь между документами.
 META: Метаопределения (например, ключевые слова, описание).
 STYLE: Описывает стили документа.
SCRIPT: Содержит код исполняемых сценариев.

## Метаопределения <META>

•   Содержат параметры для описания внутренних свойств HTML-файла.
•   Типы данных: HTTP-EQUIV и NAME.

    *   Пример HTTP-EQUIV: <META HTTP-EQUIV="refresh" content="10; URL=http://www.site.ru"> (перенаправление через 10 секунд).
    *   Пример NAME: <META NAME="keywords" CONTENT="ключевое слово 1, ключевое слово 2"> (ключевые слова).
    *   Пример NAME: <META NAME="description" CONTENT="Описание документа"> (описание документа).

## Раздел BODY

Содержит основные параметры:

    *   BGCOLOR: Цвет фона.
    *   BACKGROUND: Фоновый рисунок.
    *   TOPMARGIN, BOTTOMMARGIN, LEFTMARGIN, RIGHTMARGIN: Отступы от краев документа.
    *   TEXT: Цвет основного текста.
    *   ALINK: Цвет активных ссылок.
    *   LINK: Цвет непосещенных ссылок.
    *   VLINK: Цвет посещенных ссылок.

## Форматирование текста

•   Логическое форматирование: Отображает элементы документа в соответствии со спецификацией HTML.
•   Физическое форматирование: Позволяет визуально изменять текст.

### Теги логического форматирования

•   <ACRONYM>: Расшифровка аббревиатур.
•   <CITE>: Цитаты и высказывания (курсив).
•   <DEL>: Удаленный текст (зачеркнутый).
•   <EM>: Интонационное выделение (курсив).
•   <H1> - <H6>: Заголовки разных размеров.
•   <STRONG>: Выделение (жирный).

### Теги физического форматирования

•   <B>: Жирный.
•   <BIG>: Увеличенный шрифт.
•   <BLINK>: Мигающий текст.
•   <I>: Курсив.
•   <SMALL>: Уменьшенный шрифт.
•   <SUB>: Нижний индекс.
•   <SUP>: Верхний индекс.
•   <TT>: Моноширинный текст.
•   <U>: Подчеркнутый текст.
•   <FONT>: Указание свойств шрифта (цвет, размер, название).

    *   FACE: Выбор шрифта.
    *   COLOR: Выбор цвета.
    *   SIZE: Размер шрифта (от 1 до 7).

## Структурное форматирование

•   Разбиение текста на логические блоки: абзацы, текстовые блоки, центрирование, отступы, перенос строки, горизонтальные разделители.

### Создание абзацев

•   <P>: Обозначение абзаца.
•   ALIGN: Выравнивание текста в абзаце (left, center, right, justify).

### Текстовый блок

•   <DIV>: Принудительный перенос строки после закрытия тега.

•   <SPAN>: Назначение новых правил отображения без изменения структуры документа.

### Отступ строки

•   &nbsp;: Неразрывный пробел.

### Перенос строки

•   <BR>: Принудительный перенос строки.

### Запрет переноса

•   <NOBR></NOBR>: Запрет переноса словосочетания.

### Горизонтальный разделитель

•   <HR>: Горизонтальная линия.

    *   WIDTH: Длина линии.
    *   SIZE: Ширина линии.
    *   ALIGN: Выравнивание линии.
    *   COLOR: Цвет линии.
    *   NOSHADE: Отмена рельефности линии.

## Комментарии

•   <!-- Комментарий -->: Текст, который не отображается в браузере.

## Гипертекстовые ссылки

•   <A>: Указатель ссылки.
•   HREF: Адрес перехода.

    *   Пример: <A HREF="http://www.tpu.ru">Томский политехнический университет</A>.
    *   Ссылка на email: <A HREF="mailto:mail@site.ru?Subject=Здравствуйте!">Отправить письмо</A>.
    *   Ссылка на файл: <A HREF="http://www.site.ru/docs/dogovor.doc">Скачать договор</A>.
    *   Внутренние ссылки: <A HREF="#font">FONT</A> и <A NAME="font"></A>.

## Списки

•   Нумерованные списки: <OL>.

    *   TYPE: Тип нумерации (I, i, A, a).
    *   START: Начальная позиция списка.
    *   <LI>: Элемент списка.

•   Маркированные списки: <UL>.

    *   TYPE: Тип маркера (disc, circle, square).
    *   <LI>: Элемент списка.

## Таблицы

•   <TABLE>: Основной тег таблицы.
•   <TR>: Строка таблицы.
•   <TD>: Ячейка таблицы.
•   <TH>: Ячейка заголовка таблицы (жирный текст).
•   <CAPTION>: Заголовок таблицы.
•   Параметры тега <TABLE>:

    *   BORDER: Рамка таблицы.
    *   CELLSPACING: Расстояние между ячейками.
    *   CELLPADDING: Отступ между рамкой ячейки и содержимым.
    *   ALIGN: Выравнивание таблицы.
    *   WIDTH, HEIGHT: Ширина и высота таблицы.

•   Параметры тегов <TR>, <TD>, <TH>:

    *   ALIGN: Выравнивание содержимого ячейки по горизонтали.
    *   VALIGN: Выравнивание содержимого ячейки по вертикали.
    *   BGCOLOR: Цвет ячейки.
    *   BACKGROUND: Фоновое изображение ячейки.
    *   WIDTH, HEIGHT: Ширина и высота ячейки.
    *   COLSPAN, ROWSPAN: Объединение ячеек.

## Добавление графики

•   <IMG>: Тег для добавления изображений.

    *   SRC: Путь к изображению (обязательный параметр).
    *   BORDER: Рамка вокруг изображения.
    *   WIDTH, HEIGHT: Ширина и высота изображения.
    *   HSPACE, VSPACE: Отступы от изображения.
    *   TITLE: Всплывающая подсказка.
    *   ALIGN: Выравнивание изображения относительно текста (left, right, top, texttop, middle, absmiddle, bottom, baseline, absbottom).

# Лекция 1: Введение в Web

## О чем курс?
*   Фундаментальный web
*   Advanced javascript
*   Клиентская разработка (vanilla js)
*   Серверная разработка (node.js)
*   Real-time messages (polling, websocket)

## Лекции
1.  Введение в Web
2.  Основы JavaScript
3.  Модель клиент-сервер
4.  Запросы AJAX
5.  Асинхронный JavaScript
6.  Бэкенд на JavaScript
7.  Web реального времени

## Контрольные мероприятия
*   **Модуль 1:**
    *   1 РК
    *   3 ЛР
    *   1 ДЗ
*   **Модуль 2:**
    *   1 РК
    *   3 ЛР
    *   Доп задание

## Web
*   Подробнее: [https://vc.ru/selectel/76371-chto-proishodit-kogda-polzovatel-nabiraet-v-brauzere-adres-sayta](https://vc.ru/selectel/76371-chto-proishodit-kogda-polzovatel-nabiraet-v-brauzere-adres-sayta)

## Базовый сценарий работы web-приложения
1.  Пользователь вводит URL
2.  Браузер загружает страницу (HTML документ)
3.  Браузер анализирует (парсит) HTML и загружает доп. ресурсы
4.  Браузер отображает (рендерит) HTML-страницу

## URL - unified resource locator
*   `http://mi-ami.ru:8080/profile/account.html?gender=male&age=13#comments`
    *   `http` - протокол
    *   `mi-ami.ru` - доменное имя (DNS имя сервера)
    *   `8080` - TCP порт
    *   `/profile/account.html` - путь до документа
    *   `?gender=male&age=13` - query-параметры (параметры запроса)
    *   `#comments` - якорь

## Документы
*   Тело ответа HTTP-запроса.
*   Типы (MIME-типы):
    *   `text/html`
    *   `text/css`
    *   `text/javascript`
    *   `image/png`
    *   `video/mp4`
    *   и т.д.
*   По смыслу:
    *   **Статические:** Файлы на дисках сервера, с постоянным адресом.
    *   **Динамические:** Создаются на каждый запрос, содержимое зависит от внешних факторов, адрес может меняться.

## HTTP
*   Протокол передачи гипертекста.
*   Работает поверх TCP.
*   Технология "клиент-сервер".
*   Каждый запрос браузера за ресурсами - это HTTP-запрос.

## Структура HTTP-запроса
*   Метод (GET, POST, PUT, DELETE и т.д.)
*   URL запроса (адрес ресурса)
*   Заголовки (характеризуют тело сообщения, параметры передачи и прочие сведения)
*   Тело (может отсутствовать)

## Структура HTTP-ответа
*   Тело
*   Заголовки
*   Статус ответа:
    *   `1xx` - информативный статус
    *   `2xx` - успешный статус
    *   `3xx` - перенаправление
    *   `4xx` - клиентская ошибка
    *   `5xx` - ошибка сервера

## HTML
*   Подробнее: [http://htmlbook.ru/html](http://htmlbook.ru/html)

## DOCTYPE
*   Указание типа содержимого.
    *   HTML 5: `<!DOCTYPE html>`

## Конспект Лекции 2: JavaScript

### Основы JavaScript

•   [https://learn.javascript.ru/first-steps](https://learn.javascript.ru/first-steps)

### Переменные

•   var, let, const
    *   let - современный способ объявления.
    *   var - устаревший способ.
    *   const - значение переменной не может изменяться.

### Типизация

•   JavaScript - не строго типизированный язык.

### Преобразование типов

•   Примеры преобразований типов при сравнении.

### Математические операции

•   +, -, -b (отрицание), %, *, /, +=, ++

### Операторы сравнения

•   >, >=, <, <=, ==, ===, !=, !==

### Оператор условий

•   if (условие) { ... } else { ... }
•   Тернарный оператор: (условие) ? значение1 : значение2

### Циклы

•   while (condition) { ... }
•   do { ... } while (condition);
•   for (начало; условие; шаг) { ... }

### Функции

•   function имя(параметры) { ...тело... }

### Function Expression vs Function Declaration

•   Function Expression: создаётся, когда выполнение доходит до него, и затем уже может использоваться.
•   Function Declaration: может быть вызвана раньше, чем она объявлена.

### Стрелочные функции

•   const sum1 = (a, b) => a + b;
•   const sum2 = (a, b) => { ... return result; };

### Объекты

•   [https://learn.javascript.ru/object-basics](https://learn.javascript.ru/object-basics)
•   Объект - структура "ключ - значение".
•   Создание:
    *   let user = new Object(); (конструктор)
    *   let user = {}; (литерал)

### Доступ к полям объекта

•   const user = { name: "John", age: 30 };
•   console.log(user.name);
•   console.log(user["age"]);

### Присваивание полей. Вычисляемые свойства

•   user.isAdmin = true;
•   const key = 'age'; user[key] = 18;

### Сравнение объектов

•   Объекты сравниваются по ссылке.

### this или магическая область видимости

•   this внутри функции - это объект "перед точкой".

### Псевдо-ООП

•   Использование функций-конструкторов для создания объектов.

### Типы данных

•   [https://learn.javascript.ru/data-types](https://learn.javascript.ru/data-types)
•   Примитивы: string, number, boolean, symbol, null, undefined, bigint

### Примитив как объект

•   Примитивы остаются примитивами.
•   Для доступа к методу создается "объект-обертка", который предоставляет нужную функциональность, а потом удаляется.
•   Объекты обертки примитивов: String, Number, Boolean, Symbol, BigInt

### Числа

•   Разные формы записи чисел (десятичная, шестнадцатеричная и т.д.)

### Числа (методы)

•   num.toString(base) - число в строку
•   num.toFixed(digits) - округление в меньшую сторону

### Числа (округление)

•   Math.floor(num) - округление в меньшую сторону
•   Math.ceil(num) - округление в большую сторону
•   Math.round(num) - округление до ближайшего целого
•   Math.trunc(num) - удаление дробной части

### Числа (неточные выражения)

•   Слишком большие числа, сложение дробных чисел, потеря точности.

### Числа (проверки)

•   isNaN(value) - проверка на NaN
•   isFinite(value) - преобразование в число, проверка что это число
•   Number.isNaN(value) - строгая проверка isNaN
•   Number.isFinite(value) - строгая проверка isFinite

### Числа (преобразование)

•   +value или Number(value) - преобразование в число
•   parseInt(value) - преобразование в число (только число из строки)
•   parseFloat(value) - преобразование в число (только число из строки)

### Строки

•   Одинарные, двойные и обратные кавычки.
•   Обратные кавычки позволяют использовать интерполяцию: ${переменная}

### Строки (доступ к символам)

•   Доступ к символам как у массива: str[0], str.at(0), str.at(-1)

### Строки (неизменяемы)

•   Строки неизменяемы. Нельзя изменить символ по индексу.

### Строки (методы)

•   str.length - длина строки
•   str.indexOf(str, pos) - получение индекса наличия подстроки (с начала)
•   str.lastIndexOf(str, pos) - получение индекса наличия подстроки (с конца)
•   str.toLowerCase() - преобразование в нижний регистр
•   str.toUpperCase() - преобразование в верхний регистр
•   str.includes(str, pos) - проверка наличия подстроки (с позиции)
•   str.startsWith(str) - проверка наличия подстроки (с начала)
•   str.endsWith(str) - проверка наличия подстроки (с начала)

### Строки (получение подстроки)

•   str.slice(start, end) - возвращает часть строки от start (не включая) до end
•   str.substring(start, end) - возвращает часть строки между start и end
•   str.substr(start, length) - возвращает часть строки от start длины length

### Массивы

•   Создание: let arr = new Array();, let arr = [];
•   Массивы могут хранить разные типы данных.

### Массивы (доступ)

•   arr[]
•   arr.at(index)

### Массивы (методы)

•   arr.length - длина массива
•   arr.pop() - удаление последнего элемента
•   arr.push(el) - добавление в конец массива
•   arr.shift() - удаление первого элемента
•   arr.unshift(el) - добавление в начало массива

### Массивы (добавление/удаление значений)

•   arr.slice(start, end) - создание нового массива с start до end (не включая)
•   arr.concat(arg1, arg2...) - создание нового массива с добавлением argN

### Массивы (перебор элементов)

•   Цикл for
•   Цикл for of
•   Метод forEach

### Массивы (поиск)

•   arr.indexOf(el, start) - получение индекса элемента (с начала)
•   arr.lastIndexOf(el, start) - получение индекса элемента (с конца)
•   arr.includes(el, start) - проверка наличия элемента
•   arr.find(function(el, index)) - получение элемента по условию
•   arr.findIndex(function(el, index)) - получение индекса по условию (с начала)
•   arr.findLastIndex(function(el, index)) - получение индекса по условию (с конца)

### Массивы (преобразование массива)

•   arr.filter(function(el, index)) - получение нового массива по условию
•   arr.map(function(el, index)) - преобразование каждого элемента
•   arr.sort(function(el1, el2)) - сортировка массива
•   arr.reverse() - меняет порядок элементов на обратный
•   str.split(delim) - преобразование строки в массив
•   arr.join(glue) - преобразование массива в строку
•   arr.reduce(function(acc, el, index))

### Массивы (проверка)

•   Array.isArray(arr) - проверка, что элемент массив

### Object (методы)

•   Object.keys(obj) - получение массива ключей
•   Object.values(obj) - получение массива значений
•   Object.entries(obj) - получение массива ключ/значение

### Деструктуризация (массив)

•   let [firstName, surname] = arr;
•   Значения по умолчанию: let [name = "Guest", surname = "Anonymous"] = ["Julius"];

### Деструктуризация (объект)

•   let {title, width, height} = options;
•   Сборка остатка: let {title, ...rest} = options;
•   Переименование: let {width: w = 100, height: h = 200, title} = options;

### Деструктуризация (вложенные)

•   Деструктуризация вложенных объектов.

### Деструктуризация (функции)

•   Деструктуризация параметров функции.

### Map

•   Коллекция ключ/значение.
•   let map = new Map();
•   map.set("1", "str1");, map.set(1, "num1");, map.set(true, "booll");
•   map.get(1);, map.get("1");
•   map.size

### Мар (методы)

•   map.set(key, value)
•   map.get(key)
•   map.has(key)
•   map.delete(key)
•   map.clear()
•   map.size()
•   map.keys() - получение массива ключей
•   map.values() - получение массива значений
•   map.entries() - получение массива ключ/значение

### Set

•Коллекция значений.
•   let set = new Set();
•   Хранит только уникальные значения.
•   set.add(john);, set.add(pete);, set.add(mary);, set.add(john);
•   set.size

### Set (методы)

•   set.add(value)
•   set.has(value)
•   set.delete(value)
•   set.clear()
•   set.size()
•   set.keys() - получение массива значений
•   set.values() - получение массива значений
•   set.entiers() - получение массива значение/значение

### JSON (stringify)

•   Преобразование объекта в строку JSON: let json = JSON.stringify(student);

### JSON (parse)

•   Преобразование строки JSON в объект: numbers = JSON.parse(numbers);

### Классы

•   [https://learn.javascript.ru/classes](https://learn.javascript.ru/classes)

### Класс

•   class User { ... }
•   constructor(name) { this.name = name; }
•   sayHi() { alert(this.name); }
•   let user = new User("Иван"); user.sayHi();

### Класс (что это?)

•   Класс - это функция.

### Классы (геттеры/сеттеры)

•   get name() { return this._name; }
•   set name(value) { ... this._name = value; }

### Классы (статические свойства)

•   static publisher = "Илья Кантор";
•   Article.publisher

### Классы (статические методы)

•   static compare(articleA, articleB) { return articleA.date - articleB.date; }
•   articles.sort(Article.compare);

### Классы (наследование)

•   class Rabbit extends Animal { ... }

### Классы (наследование, переопределение методов)

•   super.stop();

### Классы (наследование, переопределение конструктора)

•   constructor(name, earLength) { ... }

### Классы (приватные свойства)

•   _waterAmount = 0; (convention)
•   #waterLimit = 200; (private)

### Классы (проверка)

•   rabbit instanceof Rabbit
•   rabbit instanceof Animal

# Лекция 3: Углубленный JavaScript

## Продвинутая работа с функциями

### Rest-оператор
•   Позволяет функции принимать неопределенное количество аргументов.
•   Аргументы собираются в массив.
•   Синтаксис: `function sumAll(...args) {}`

### Arguments
•   Устаревший способ получения всех аргументов функции.
•   Доступен как псевдомассив `arguments` внутри функции.
•   Не работает в стрелочных функциях.

### Spread-оператор
•   Позволяет передать массив аргументов в функцию.
•   Синтаксис: `Math.max(...arr1, ...arr2)`

## Замыкание

•   Функция, которая запоминает свои внешние переменные и может получить к ним доступ.
•   Лексическое окружение:
    •   `Environment Record` - хранилище локальных переменных.
    •   Ссылка на внешнее лексическое окружение.
•   Переменная - это свойство `Environment Record`.
•   `Function Declaration` инициализируются раньше, чем переменные, объявленные через `let`.
•   Все функции «при рождении» получают скрытое свойство `[[Environment]]`, которое ссылается на лексическое окружение места, где они были созданы.
•   `Immediately-Invoked Function Expressions` (IIFE) - функция, которая вызывается сразу после ее объявления.

### Устаревшее объявление переменных (var)

•   Переменные `var` не имеют блочной области видимости, они ограничены телом функции.
•   Объявления (инициализация) переменных `var` производится в начале исполнения функции.

### Функция-обертка (декорация)

•   Функция, которая оборачивает другую функцию, добавляя ей новую функциональность.
•   Пример: кеширование результатов функции.
•   Для работы с методами объектов необходимо привязывать контекст (`this`).

### Привязка контекста

•   `func.call(context, arg1, arg2, ...)` - вызывает функцию с указанным контекстом и аргументами.
•   `func.apply(context, [arg1, arg2, ...])` - вызывает функцию с указанным контекстом и массивом аргументов.
•   `func.bind(context)` - возвращает новую функцию с привязанным контекстом.

## Прототипы, наследование

•   Каждый объект в JavaScript имеет скрытое свойство `[[Prototype]]`, которое ссылается на другой объект (прототип).
•   Если свойство не найдено в объекте, поиск продолжается в его прототипе.
•   `__proto__` - устаревший способ доступа к прототипу.
•   `F.prototype` - свойство функции-конструктора, которое используется для установки прототипа для новых объектов, созданных с помощью `new`.
•   `prototype` по умолчанию – объект с единственным свойством `constructor`, которое ссылается на функцию-конструктор.
•   Встроенные прототипы: `Array.prototype`, `Object.prototype`, `Function.prototype`, `Number.prototype`.

### Классы

•   Синтаксис для создания объектов и наследования.
•   `extends` - ключевое слово для наследования от другого класса.
•   `static` - статические методы класса.

## Модули

•   AMD, CommonJS, UMD - устаревшие модульные системы.
•   ESM (ECMAScript Modules) - стандартный способ организации модулей в JavaScript.
•   Модуль - это файл.
•   Директивы `export` и `import` для обмена функциональностью между модулями.
•   `export` - отмечает переменные и функции, которые должны быть доступны вне текущего модуля.
•   `import` - позволяет импортировать функциональность других модулей.
•   Модули выполняются только 1 раз.
•   "Голые" модули - ошибка, путь должен быть относительным или абсолютным.
•   `export default` - экспорт по умолчанию.
•   `re-export` - реэкспорт из другого модуля.
•   `dynamic import` - динамический импорт модулей (с использованием `await import()`).

## Обработка ошибок

•   `try...catch` - конструкция для обработки ошибок.
•   `try` - блок кода, в котором может произойти ошибка.
•   `catch` - блок кода, который выполняется, если в блоке `try` произошла ошибка.
•   `finally` - блок кода, который выполняется всегда (после `try` или `catch`).
•   Объект ошибки:
    •   `name` - имя ошибки.
    •   `message` - сообщение об ошибке.
    •   `stack` - текущий стек вызова.
•   Генерация ошибок: `throw new Error(message)`.
•   Пользовательские ошибки: создание собственных классов ошибок, наследующихся от `Error`.

## Регулярные выражения

•   Шаблоны для поиска и замены текста.
•   Создание:
    •   `new RegExp("шаблон", "флаги")`
    •   `/шаблон/gmi`
•   Методы:
    •   `str.match(regexp)` - поиск совпадений.
    •   `str.replace(regexp, replacement)` - замена текста.
    •   `regexp.test(str)` - проверка на соответствие шаблону.

## События

•   Действия, происходящие в браузере (клик, наведение мыши, нажатие клавиши и т.д.).
•   События мыши: `click`, `contextmenu`, `mouseover`, `mouseout`, `mousedown`, `mouseup`, `mousemove`.
•   События на элементах управления: `submit`, `focus`.
•   Клавиатурные события: `keydown`, `keyup`.
•   Обработчики событий:
    •   Атрибут `onclick` в HTML.
    •   Свойство `element.onclick` в JavaScript.
    •   Метод `element.addEventListener(event, handler)`.
•   Объект события:
    •   `event.type` - тип события.
    •   `event.currentTarget` - элемент, на котором сработал обработчик.
    •   `event.clientX`, `event.clientY` - координаты курсора.
•   Всплытие и погружение событий: порядок обработки событий на вложенных элементах.
•   `event.stopPropagation()` - остановка всплытия события.
•   `event.stopImmediatePropagation()` - остановка всплытия и обработки других обработчиков на текущем элементе.
•   `event.preventDefault()` - отмена действия браузера по умолчанию.
•   Пользовательские события: создание и отправка собственных событий.

# Лекция 4: Архитектура Web

▌Что находится внутри браузера?

•  Браузер загружает основную структуру HTML-страницы.
•  Последовательно проверяет теги и отправляет GET-запросы для получения ресурсов (картинки, скрипты, стили и т.д.).
•  Браузер и сервер обмениваются информацией в процессе загрузки.
•  После завершения рендеринга пользователю отображается полностью загруженная страница.

▌Критические этапы рендера

•  Критические этапы рендеринга (Critical Rendering Path) - последовательность шагов, выполняемых браузером для преобразования HTML, CSS и JavaScript в пиксели на экране.
  1. Загрузка HTML
  2. DOM
  3. CSSOM
  4. Дерево рендера (render tree)
  5. Компоновка (layout)
  6. Отрисовка (paint)

▌Document Object Model (DOM)

•  HTML преобразуется в токены, затем в узлы (nodes), формирующие DOM-дерево.
•  Узел содержит информацию об HTML-элементе.
•  Узлы связаны с Render Tree с помощью иерархии токенов.

▌CSS Object Model (CSSOM)

•  DOM содержит содержимое страницы, а CSSOM - стили.
•  Формирование DOM инкрементально, CSSOM - нет.
•  CSS блокирует рендер до получения и обработки всех CSS-правил.

▌Дерево рендера (Render Tree)

•  Объединяет содержимое страницы и стили (DOM + CSSOM).
•  Браузер проверяет каждый узел DOM и определяет, какие CSS-правила применить.
•  Содержит только видимое содержимое.
•  Элементы с display: none не включаются в дерево.

▌Компоновка (Layout)

•  Определение положения и размеров элементов из Render Tree.
•  Рекурсивный процесс, начинающийся от корневого Render Object.
•  Каждый render object получает свое положение и размеры.

▌Отрисовка (Paint)

•  Отрисовка пикселей на экране после создания дерева рендера и компоновки.
•  При первичной загрузке отрисовывается весь экран.
•  В дальнейшем перерисовываются только необходимые части экрана.

▌Ограничения JS в браузере

•  Нельзя взаимодействовать с файловой системой.
•  Ограниченный доступ к сетевым функциям.
•  Ограниченные возможности многопоточных вычислений (воркеры).
•  Нельзя создавать новые процессы/запускать программы.

▌Npm

•  Node.js - исполнение JavaScript кода вне браузера.
•  Npm - Node Package Manager (менеджер пакетов для Node.js).
  •  CLI (интерфейс командной строки) для публикации и загрузки пакетов.
  •  Онлайн-репозиторий пакетов JavaScript.

▌Подключение библиотек

•  CDN
•  Npm
  1. npm install bootstrap@5.3.0-alpha2
  2. import { ... } from 'bootstrap'

▌Создание своего модуля Npm

•  npm init - инициализация приложения.
•  package.json - файл с описанием приложения.
•  package-lock.json - файл с версиями зависимостей.

▌Архитектурные решения

•  Оценка архитектурного решения:
  •  Что если я ошибся и мне придется изменить это решение в будущем? Какие будут последствия?
•  Решение, "размазанное" по всему приложению, является архитектурным.

▌Методологии и принципы

•  DRY - Don't Repeat Yourself (не повторяйте себя).
•  KISS - Keep It Simple, Stupid (делайте вещи проще).
•  S.O.L.I.D. - принципы объектно-ориентированного программирования и проектирования.

▌Декомпозиция

•  Internal Cohesion - сопряженность внутри модуля.
•  External Coupling - связанность взаимодействующих модулей.

▌Декомпозиция (функциональная)

•  Паттерн "Модуль": Функция + Данные, необходимые для её выполнения.
  •  Инкапсуляция данных.
  •  Явное управление зависимостями.
  •  Уход от засорения глобального контекста.
•  ОДИН файл — ОДИН модуль
•  Не допускать циклические зависимости

▌Проектирование системы

•  Какую функцию выполняет каждый модуль?
•  Насколько модули легко тестировать?
•  Возможно ли использовать модули самостоятельно?
•  Как изменения в одном модуле отразятся на остальных?

▌Критерии хорошего дизайна системы

•  Эффективность.
•  Гибкость и расширяемость.
•  Масштабируемость.
•  Тестируемость и сопровождаемость.
•  Возможность повторного использования.

▌Декомпозиция (компоненты)

•  Компонентный подход - разделение кода на независимые, слабосвязанные и переиспользуемые компоненты.
занные и переиспользуемые компоненты.
•   Компоненты могут быть сложными внутри, но простыми для использования снаружи.

## Шаблоны MVC

•   Разделение данных, представления и управления.

## Модели MVC

•   Содержат бизнес-логику.
•   Не взаимодействуют с пользователем напрямую.
•   Не генерируют HTML.
•   Хранят данные и взаимодействуют с другими моделями.

## Представления MVC

•   Отвечают за отображение данных.
•   Получают данные от моделей или контроллеров.
•   Взаимодействуют с моделями через контроллеры.
•   Являются посредниками между пользователем и контроллером.

## Контроллеры MVC

•   Связующее звено приложения.
•   Реализуют взаимодействие между вьюхами и моделями.
•   Содержат минимум бизнес-логики.
•   Логика контроллера выносится в базовые классы.

## Собираем MVC

•   Создаём базовый класс View.
•   Наследуем от него конкретные View.
•   Во вьюхах описываем отображение.
•   Содержимое View генерируется шаблонизатором.
•   Активна только одна View в момент времени.

## Роутинг

•   Переключение между View.

## Роутер (паттерн медиатор)

•   Определение маршрута внутри приложения.
•   Поиск контроллера по URL.
•   Соответствие между состоянием приложения и View.

## History API

•   Эмуляция истории переходов в SPA-приложениях.
•   Манипулирование историей браузера.

## Архитектура CSS

•   Браузерные стили.
•   <link rel="stylesheet">.
•   <style>.
•   Атрибут style.

## Проблемы CSS

•   Зависимость от родителя
•   Сложно найти элемент на странице "в слепую"
•   Пересечение имён с внешними библиотеками

## Признаки хорошей архитектуры CSS

•   Предсказуемость.
•   Масштабируемость.
•   Поддержка.
•   Повторное использование (DRY).

## Объектно-ориентированный CSS

•   Разделение структуры и оформления.
•   Разделение контейнера и содержимого.

## Масштабируемая и модульная архитектура CSS

•   SMACSS

## Выводы

•   Избавляемся от каскадирования!
•   Придумываем слои: компонент -> приложение -> глобальные стили
•   Держим стили внутри своего слоя: button.html + button.css + button.js
•   Расширяем компоненты через глобальные mixin-классы: .animated, .themed, .hidden, .row

## CSS через JS

•   Представление стилей через объект.
•   Темизация в runtime.
•   Уменьшение размера загружаемых стилей.
•   Не кешируется.

## CSS Modules

•   Использование CSS Modules

## JSS

•   Использование JSS

# Лекция 5: Node.js

## Поиск сервера

•   **IP-адрес:** У каждого сервера есть IP-адрес.
•   **DNS (Domain Name System):** Распределенная система серверов, хранящая информацию об IP-адресах сайтов.

## TCP соединение

•   **TCP:** Специальный протокол для установления соединения между браузером и сервером.
•   **Трех рукопожатий:** Система для установления TCP-соединения.

## Тройное рукопожатие

1.  **SYN-пакет:** Устройство пользователя отправляет запрос на установку соединения.
2.  **SYN/ACK-пакет:** Сервер отвечает запросом с подтверждением.
3.  **ACK-пакет:** Устройство пользователя отправляет подтверждение, соединение установлено.

## Остальные шаги

1.  Браузер отправляет HTTP-запрос.
2.  Сервер получает и обрабатывает запрос.
3.  Сервер отправляет ответ браузеру.
4.  Браузер обрабатывает ответ и отображает веб-страницу.

## Клиент-сервер

•   **Клиент-серверная модель:** Вычислительная или сетевая архитектура, где нагрузка распределена между серверами и клиентами.

## Статические веб-страницы

•   **Frontend:** Отображение HTML, CSS, контент, переходы по ссылкам.
•   **Backend:** Хранение и отдача статических документов.

## SSR (server side rendering) – динамические документы

•   **Frontend:** Отображение HTML, CSS, контент, переходы по ссылкам, взаимодействие с формами.
•   **Backend:** Хранение, отдача документов, обработка запросов, генерация страниц, хранение данных в БД.

## Веб-сервисы, веб-приложения

•   **Frontend:** Хранение контента, генерация интерфейса, взаимодействие с пользователем.
•   **Backend:** Реализация API, хранение данных.

## REST – Передача состояния

•   Каждый запрос должен содержать всю необходимую информацию для выполнения действия на сервере.

## Что такое Node.js?

•   Среда выполнения JavaScript на основе движка Google V8.
•   Используется для: веб-приложений (бэкенд), десктопных приложений, микроконтроллеров, консольных утилит, машинного обучения.

## Преимущества

•   Быстрый сервер (сравним с Java, Kotlin, Golang).
•   Асинхронный API (не блокирует основной поток).
•   Легко поднять простой веб-сервер.
•   Можно использовать различные парадигмы программирования.

## Отсутствие типизации

•   JavaScript - нестрого типизированный язык.

## Другие проблемы разработки на JS

•   Отсутствие многопоточности.
•   Медленные вычисления.
•   Плохое ООП.
•   Скудные коллекции.
•   RunTime-ошибки.

## Как использовать Node.js

1.  Создать файл <название>.js.
2.  Написать код на JavaScript.
3.  Запустить командой node <название>.js.
4.  Обратиться по HTTP.

## Стандартная библиотека

•   events, fs, os, http, net, path.

## Так как используют Node.js?

•   Серверная разработка: SSR, BFF, Full-Backend API, микросервисы.

## Nest.js

•   Фреймворк для создания эффективных, расширяемых серверных приложений на TypeScript.
•   Преимущества: готовая архитектура, готовые решения для middleware, удобные механизмы валидации, возможность grpc, dependency injection, java-подобное приложение.

## TypeScript (vs JS)

•   TypeScript - язык с обратной совместимостью с JavaScript.
•   Преимущества: статическая типизация, интерфейсы, кортежи, декораторы, ООП, поддержка IDE, ES6-модули.

## Аннотации типов

•   Примеры аннотаций типов.

## Задание в лабораторной

•   Задание по созданию API для работы с карточками.

## Postman

•   Используется для тестирования веб-сервисов.
•   Для создания записи необходимо передать JSON на сервер.

## Наши первоначальные данные - mock

•   Пример данных в формате JSON.

## Модель из MVC – Сервис в NestJS

•   Пример реализации модели в NestJS.

## Контроллер – обработчики HTTP запросов

•   Пример реализации контроллера в NestJS.

# Лекция 6: AJAX

## Интернет, HTTP и AJAX

•   AJAX позволяет асинхронно взаимодействовать с сервером без перезагрузки страницы.
•   Использует XMLHttpRequest для отправки и получения данных в различных форматах (XML, HTML, текст).

## Что передаем по сети

•   Текстовые данные, JSON, бинарные данные, файлы.
•   JSON - общий формат для представления значений и объектов.

## Blob и FormData

•   Blob - объект JavaScript для работы с бинарными данными.
•   FormData - объект JavaScript для работы с формами и файлами.

## XMLHttpRequest

•   Встроенный в браузер объект для HTTP-запросов к серверу без перезагрузки страницы.
•   Режимы работы: синхронный и асинхронный.

### Основные этапы использования XMLHttpRequest:

1.  Создание XHR: let xhr = new XMLHttpRequest();
2.  Инициализация: xhr.open('GET', '/url');
3.  Отправка запроса: xhr.send();
4.  Обработка ответа:
    •   xhr.onload - обработчик успешного ответа.
    •   xhr.onerror - обработчик ошибки.
    •   xhr.onprogress - обработчик прогресса загрузки.
    •   xhr.status - HTTP статус ответа.
    •   xhr.statusText - текстовое описание статуса.
    •   xhr.response - тело ответа.
    •   xhr.responseType - тип ожидаемого ответа (text, arrayBuffer, blob, document, json).
    •   xhr.readyState - состояние запроса (UNSET, OPENED, HEADERS_RECEIVED, LOADING, DONE).

# Лекция 7: Асинхронный JavaScript

## Асинхронность в JavaScript

•   Строки кода в JS не ожидают окончания выполнения предыдущей.
•   Строки порождают задачи, выполнение которых может занять много времени.

## Event Loop

•   JavaScript однопоточный и асинхронный.
•   **Макротаски:** любые функции отложенного вызова (callback).
•   **Микротаски:** промисы и MutationObserver.
•   **Рендеринг:** Paint, Layout, requestAnimationFrame.
•   Задачи попадают в Call Stack и выполняются через Event Loop.
•   Event Loop определяет, какой задаче когда выполняться.

## Callback Hell

•   Проблема: код становится нечитаемым, много отступов, высокий шанс ошибиться.
•   Решение: Promise.

## Promise

•   **Promise (обещание)** - обертка для переменных, значения которых неизвестны на момент создания.
•   Позволяет организовывать асинхронный код как синхронный.
•   Состояния Promise:
    •   **pending** (ожидание)
    •   **fulfilled** (выполнено успешно)
    •   **rejected** (выполнено с ошибкой)
•   К Promise можно привязать два коллбека:
    •   **onFulfilled:** срабатывает при успешном выполнении.
    •   **onRejected:** срабатывает при ошибке.
•   Обработка ошибок в цепочке Promise: обработчик onRejected (внутри catch) перехватывает ошибку, пропуская блоки then.
•   Методы Promise:
    •   `Promise.all`: ожидает выполнения всех промисов.
    •   `Promise.race`: возвращает результат самого быстрого промиса.
    •   `Promise.any`: возвращает результат первого fulfilled промиса.
    •   `Promise.allSettled`: ожидает выполнения всех промисов, независимо от результата.

## Async/Await

•   Async функции всегда возвращают Promise.
•   `await` используется для ожидания результата Promise.

## Fetch API

•   Метод `fetch` - XMLHttpRequest нового поколения.
•   Улучшенный интерфейс для запросов к серверу, построен на промисах.
•   `fetch(url, options)`
    •   `method`: метод запроса (GET, POST, и т.д.).
    •   `headers`: заголовки запроса.
    •   `body`: тело запроса (FormData, Blob, строка и т.п.).

## Браузерная поддержка и транспиляция

•   ECMAScript - стандартизация JavaScript.
•   JavaScript-движки: V8 (Chrome), SpiderMonkey (Firefox), Chakra (Edge).
•   Транспайлинг: конвертация кода с одного языка в другой (например, из ES6 в ES5).
•   Babel: многофункциональный транспилер.

## Bundler

•   Программа, которая упаковывает сложный проект со многими файлами и внешними зависимостями в один (иногда несколько) файл, который будет отправлен браузеру.
•   Vite: инструмент для сборки проектов.
